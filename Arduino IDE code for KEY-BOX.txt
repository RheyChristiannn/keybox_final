#include <WiFi.h>
#include <HTTPClient.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>

/*
 * ============================================================================
 * ESP32-S3 TO RC522 RFID MODULE WIRING DIAGRAM
 * ============================================================================
 * 
 * RC522 Pin    â†’    ESP32-S3 Pin    â†’    Description
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * SDA (SS)     â†’    GPIO 10          â†’    Slave Select (Chip Select)
 * SCK          â†’    GPIO 11          â†’    Serial Clock
 * MOSI         â†’    GPIO 12          â†’    Master Out Slave In
 * MISO         â†’    GPIO 13          â†’    Master In Slave Out
 * IRQ          â†’    Not Connected    â†’    Interrupt (not used)
 * GND          â†’    GND              â†’    Ground
 * RST          â†’    GPIO 9           â†’    Reset Pin
 * 3.3V         â†’    3.3V             â†’    Power Supply (DO NOT USE 5V!)
 * 
 * ============================================================================
 * RELAY MODULE WIRING (for Solenoid Lock)
 * ============================================================================
 * 
 * Relay Module â†’    ESP32-S3 Connection
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * VCC (Power)  â†’    5V pin (relay needs 5V to operate)
 * GND          â†’    GND
 * IN (Signal)  â†’    GPIO 4 (3.3V logic signal is sufficient)
 * 
 * Solenoid Lock Connection:
 * - Connect solenoid to relay's COM (Common) and NO (Normally Open) terminals
 * - Connect power supply (12V typically) to solenoid and relay COM
 * 
 * âš ï¸ IMPORTANT RELAY NOTES:
 * - Some relay modules are ACTIVE LOW (trigger with LOW signal)
 * - Some relay modules are ACTIVE HIGH (trigger with HIGH signal)
 * - If solenoid opens when you plug in USB, your relay is ACTIVE LOW
 * - Change RELAY_ACTIVE_HIGH to false if this happens
 * 
 * ============================================================================
 */

// ---------------------------
// WIFI SETTINGS
// ---------------------------
const char* WIFI_SSID = "";
const char* WIFI_PASSWORD = "";

// ---------------------------
// DJANGO SERVER URLs
// ---------------------------
String serverUrl = "||";
String manualTriggerUrl = "||";
String heartbeatUrl = "";

String room_code = "205";

const char* FIRMWARE_VERSION = "v1.1.0";


#define RELAY_PIN 4  // GPIO 4 - Connected to relay IN pin
#define RELAY_ACTIVE_HIGH false  

#define RELAY_ON  (RELAY_ACTIVE_HIGH ? HIGH : LOW)
#define RELAY_OFF (RELAY_ACTIVE_HIGH ? LOW : HIGH)

#define SS_PIN    10   // SDA/SS  â†’ GPIO 10
#define RST_PIN    9   // RST     â†’ GPIO 9
// SPI Pins (defined in SPI.begin):
// SCK  â†’ GPIO 11
// MOSI â†’ GPIO 12
// MISO â†’ GPIO 13

MFRC522 rfid(SS_PIN, RST_PIN);

const unsigned long SOLENOID_UNLOCK_TIME = 10000; // 10 seconds unlock time (for RFID only)
const unsigned long MANUAL_CHECK_INTERVAL = 2000; // Check for manual triggers every 2 seconds
const unsigned long RFID_SCAN_INTERVAL = 100;     // RFID scan interval
const unsigned long HEARTBEAT_INTERVAL = 30000;   // Send heartbeat every 30 seconds

// ---------------------------
// STATE MANAGEMENT
// ---------------------------
unsigned long lastManualCheckTime = 0;
unsigned long lastRfidScanTime = 0;
unsigned long lastHeartbeatTime = 0;
bool doorCurrentlyUnlocked = false;
unsigned long doorUnlockStartTime = 0;
bool manualControlActive = false;  // NEW: Track if manual control is active
String deviceID = "";  // Will store MAC address

// ---------------------------
// HELPER FUNCTIONS
// ---------------------------

// Convert RFID UID to readable hex string
String uidToString(MFRC522::Uid *uid) {
  String result = "";
  for (byte i = 0; i < uid->size; i++) {
    if (uid->uidByte[i] < 0x10) result += "0";
    result += String(uid->uidByte[i], HEX);
  }
  result.toUpperCase();
  return result;
}

// Activate relay to unlock solenoid (RFID triggered - with timer)
void unlockDoorWithTimer() {
  Serial.println("ğŸ”“ UNLOCKING DOOR (Auto-lock in 10 seconds)...");
  digitalWrite(RELAY_PIN, RELAY_ON);   // Activate relay â†’ solenoid UNLOCKED
  doorCurrentlyUnlocked = true;
  doorUnlockStartTime = millis();
  manualControlActive = false;  // Disable manual control mode
}

// Unlock door via manual control (no auto-lock)
void unlockDoorManual() {
  Serial.println("ğŸ”“ UNLOCKING DOOR (Manual Control - No Auto-lock)...");
  digitalWrite(RELAY_PIN, RELAY_ON);   // Activate relay â†’ solenoid UNLOCKED
  doorCurrentlyUnlocked = true;
  manualControlActive = true;  // Enable manual control mode
}

// Lock the door
void lockDoor() {
  digitalWrite(RELAY_PIN, RELAY_OFF);  // Deactivate relay â†’ solenoid LOCKED
  doorCurrentlyUnlocked = false;
  manualControlActive = false;  // Disable manual control mode
  Serial.println("ğŸ”’ DOOR LOCKED");
}

// Check if unlock time has expired (only for RFID-triggered unlocks)
void checkDoorTimer() {
  if (doorCurrentlyUnlocked && !manualControlActive) {
    if (millis() - doorUnlockStartTime >= SOLENOID_UNLOCK_TIME) {
      lockDoor();
      Serial.println("â° Auto-lock timer expired (RFID mode)");
    }
  }
}

// Send heartbeat to Django server
void sendHeartbeat() {
  if (WiFi.status() != WL_CONNECTED) {
    return;
  }

  HTTPClient http;
  http.begin(heartbeatUrl);
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  
  String postData = "device_id=" + deviceID + "&firmware_version=" + String(FIRMWARE_VERSION);
  
  int httpCode = http.POST(postData);
  
  if (httpCode == 200) {
    Serial.println("ğŸ’“ Heartbeat sent successfully");
    Serial.print("   Device ID: ");
    Serial.println(deviceID);
    Serial.print("   Firmware: ");
    Serial.println(FIRMWARE_VERSION);
  } else if (httpCode > 0) {
    Serial.print("âš ï¸ Heartbeat failed: HTTP ");
    Serial.println(httpCode);
  }
  
  http.end();
}

// Check for manual trigger commands from Django
void checkManualTrigger() {
  if (WiFi.status() != WL_CONNECTED) {
    return;
  }

  HTTPClient http;
  String url = manualTriggerUrl + "?room=" + room_code;
  
  http.begin(url);
  http.setTimeout(5000);  // 5 second timeout for manual checks
  int httpCode = http.GET();

  if (httpCode == 200) {
    String response = http.getString();
    
    // Parse JSON response
    StaticJsonDocument<512> doc;
    DeserializationError error = deserializeJson(doc, response);

    if (!error) {
      const char* action = doc["action"];
      bool has_trigger = doc["has_trigger"] | false;
      
      if (has_trigger && action) {
        Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Serial.println("â•‘     ğŸ–±ï¸  MANUAL TRIGGER RECEIVED          â•‘");
        Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Serial.print("  Action: ");
        Serial.println(action);
        Serial.print("  Room: ");
        Serial.println(room_code);
        Serial.println("  Mode: Manual Control (No Auto-lock)");
        
        if (String(action) == "open") {
          unlockDoorManual();  // UPDATED: Use manual unlock (no timer)
        } else if (String(action) == "close") {
          lockDoor();  // UPDATED: Lock immediately, no timer
        }
        
        Serial.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
      }
    }
  } else if (httpCode > 0 && httpCode != 404) {
    Serial.print("âš ï¸ Manual trigger check failed: HTTP ");
    Serial.println(httpCode);
  }

  http.end();
}

// ---------------------------------------------------------
// SETUP - Runs once at startup
// ---------------------------------------------------------
void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.print("â•‘   ESP32-S3 RFID Keybox System ");
  Serial.print(FIRMWARE_VERSION);
  Serial.println("      â•‘");
  Serial.println("â•‘   WITH MANUAL CONTROL SUPPORT             â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

  // â”€â”€ STEP 1: Initialize Relay Pin â”€â”€
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, RELAY_OFF);  // Ensure door stays LOCKED at boot
  
  Serial.println("âœ“ Relay Module Initialized");
  Serial.print("  â†’ Pin: GPIO ");
  Serial.println(RELAY_PIN);
  Serial.print("  â†’ Type: ");
  Serial.println(RELAY_ACTIVE_HIGH ? "ACTIVE HIGH" : "ACTIVE LOW");
  Serial.print("  â†’ Boot State: ");
  Serial.println(digitalRead(RELAY_PIN) == HIGH ? "HIGH (locked)" : "LOW (locked)");

  // â”€â”€ STEP 2: Connect to WiFi â”€â”€
  Serial.println("\nâœ“ Connecting to WiFi...");
  Serial.print("  â†’ SSID: ");
  Serial.println(WIFI_SSID);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int wifi_retry = 0;
  while (WiFi.status() != WL_CONNECTED && wifi_retry < 20) {
    delay(500);
    Serial.print(".");
    wifi_retry++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nâœ“ WiFi Connected!");
    Serial.print("  â†’ IP Address: ");
    Serial.println(WiFi.localIP());
    Serial.print("  â†’ Signal Strength: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
    
    // Get MAC address as device ID
    deviceID = WiFi.macAddress();
    deviceID.replace(":", "");  // Remove colons
    Serial.print("  â†’ Device ID (MAC): ");
    Serial.println(deviceID);
  } else {
    Serial.println("\nâœ— WiFi Connection Failed!");
    Serial.println("  â†’ Check SSID and password");
  }

  // â”€â”€ STEP 3: Initialize SPI and RFID Reader â”€â”€
  Serial.println("\nâœ“ Initializing RFID Reader...");
  
  // SPI Pin Configuration: SCK, MISO, MOSI, SS
  SPI.begin(11, 13, 12, 10);
  Serial.println("  â†’ SPI Pins: SCK=11, MISO=13, MOSI=12, SS=10");
  
  rfid.PCD_Init();
  delay(100);
  
  // Check if RFID reader is detected
  byte version = rfid.PCD_ReadRegister(rfid.VersionReg);
  if (version == 0x00 || version == 0xFF) {
    Serial.println("âœ— RFID Reader Not Detected!");
    Serial.println("  â†’ Check wiring connections");
  } else {
    Serial.println("âœ“ RFID Reader Ready");
    Serial.print("  â†’ Firmware Version: 0x");
    Serial.println(version, HEX);
    Serial.print("  â†’ SS Pin: GPIO ");
    Serial.println(SS_PIN);
    Serial.print("  â†’ RST Pin: GPIO ");
    Serial.println(RST_PIN);
  }

  // â”€â”€ STEP 4: System Ready â”€â”€
  Serial.println("\nâœ“ Server Configuration");
  Serial.print("  â†’ RFID URL: ");
  Serial.println(serverUrl);
  Serial.print("  â†’ Manual Trigger URL: ");
  Serial.println(manualTriggerUrl);
  Serial.print("  â†’ Heartbeat URL: ");
  Serial.println(heartbeatUrl);
  Serial.print("  â†’ Room Code: ");
  Serial.println(room_code);
  Serial.print("  â†’ Firmware Version: ");
  Serial.println(FIRMWARE_VERSION);
  Serial.print("  â†’ Manual Check Interval: ");
  Serial.print(MANUAL_CHECK_INTERVAL);
  Serial.println(" ms");
  Serial.print("  â†’ Heartbeat Interval: ");
  Serial.print(HEARTBEAT_INTERVAL / 1000);
  Serial.println(" seconds");
  Serial.print("  â†’ RFID Auto-lock Timer: ");
  Serial.print(SOLENOID_UNLOCK_TIME / 1000);
  Serial.println(" seconds");

  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  Serial.println("â•‘  System Ready - Waiting for commands     â•‘");
  Serial.println("â•‘  â€¢ RFID: Auto-locks after 10 seconds      â•‘");
  Serial.println("â•‘  â€¢ Manual: Direct control (no auto-lock)  â•‘");
  Serial.println("â•‘  â€¢ Heartbeat transmission                 â•‘");
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
  
  // Send initial heartbeat
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("â†’ Sending initial heartbeat...");
    sendHeartbeat();
  }
}

// ---------------------------------------------------------
// MAIN LOOP - Runs continuously (NON-BLOCKING)
// ---------------------------------------------------------
void loop() {
  unsigned long currentMillis = millis();

  // Always check if door unlock timer has expired (only for RFID mode)
  checkDoorTimer();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TASK 1: Check for manual triggers periodically
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (currentMillis - lastManualCheckTime >= MANUAL_CHECK_INTERVAL) {
    lastManualCheckTime = currentMillis;
    checkManualTrigger();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TASK 2: Send heartbeat to server periodically
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (currentMillis - lastHeartbeatTime >= HEARTBEAT_INTERVAL) {
    lastHeartbeatTime = currentMillis;
    sendHeartbeat();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TASK 3: Check for RFID cards
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (currentMillis - lastRfidScanTime >= RFID_SCAN_INTERVAL) {
    lastRfidScanTime = currentMillis;
    
    // Check if new RFID card is present
    if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
      
      // Convert UID to hex string
      String uid = uidToString(&rfid.uid);

      Serial.println("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
      Serial.println("â”‚       ğŸ“± RFID CARD DETECTED               â”‚");
      Serial.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
      Serial.print("  UID: ");
      Serial.println(uid);
      Serial.print("  Room: ");
      Serial.println(room_code);

      // Send request to Django API
      if (WiFi.status() == WL_CONNECTED) {

        HTTPClient http;
        String url = serverUrl + "?code=" + uid + "&room=" + room_code;
        
        Serial.println("\nâ†’ Sending request to Django server...");
        Serial.print("  URL: ");
        Serial.println(url);

        http.begin(url);
        http.setTimeout(10000);  // 10 second timeout
        int httpCode = http.GET();

        if (httpCode > 0) {
          Serial.print("âœ“ HTTP Response Code: ");
          Serial.println(httpCode);

          String response = http.getString();
          Serial.println("\nâ”Œâ”€â”€â”€ Server Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
          Serial.println(response);
          Serial.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

          // Parse JSON response
          if (httpCode == 200) {
            StaticJsonDocument<1024> doc;
            DeserializationError error = deserializeJson(doc, response);

            if (!error) {
              // Extract fields from Django response
              const char* status = doc["status"];
              bool access_granted = doc["access_granted"] | false;
              const char* action = doc["action"];
              const char* faculty = doc["faculty"];
              const char* message = doc["message"];
              const char* denial_reason = doc["denial_reason"];

              Serial.println("\nâ”Œâ”€â”€â”€ Parsed Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
              Serial.print("â”‚ Status: ");
              Serial.println(status);
              Serial.print("â”‚ Access Granted: ");
              Serial.println(access_granted ? "YES âœ“" : "NO âœ—");
              Serial.print("â”‚ Action: ");
              Serial.println(action);
              Serial.print("â”‚ Faculty: ");
              Serial.println(faculty);
              Serial.print("â”‚ Message: ");
              Serial.println(message);

              if (denial_reason && strlen(denial_reason) > 0) {
                Serial.print("â”‚ Denial Reason: ");
                Serial.println(denial_reason);
              }
              Serial.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

              // Check if access is granted and handle action
              if (access_granted && (String(status) == "ok")) {
                Serial.println("\nâœ… ACCESS GRANTED!");
                Serial.print("   Faculty: ");
                Serial.println(faculty);
                Serial.print("   Action: ");
                Serial.println(action);
                
                // Handle both borrow_key and return_key with 10-second timer
                if (String(action) == "borrow_key") {
                  Serial.println("   â†’ Faculty borrowing key (auto-lock in 10s)");
                  unlockDoorWithTimer();  // UPDATED: Use timer version
                } else if (String(action) == "return_key") {
                  Serial.println("   â†’ Faculty returning key (auto-lock in 10s)");
                  unlockDoorWithTimer();  // UPDATED: Use timer version
                }
                
              } else {
                Serial.println("\nâŒ ACCESS DENIED!");
                if (denial_reason && strlen(denial_reason) > 0) {
                  Serial.print("   Reason: ");
                  Serial.println(denial_reason);
                } else {
                  Serial.print("   Reason: ");
                  Serial.println(message);
                }
              }

            } else {
              Serial.println("\nâš ï¸ JSON Parse Error:");
              Serial.print("   ");
              Serial.println(error.c_str());
              Serial.println("   Door stays locked for safety.");
            }

          } else if (httpCode == 404) {
            Serial.println("\nâŒ RFID CARD NOT REGISTERED");
            Serial.println("   This card is not in the database.");
            Serial.println("   Please register the card first.");
            
          } else {
            Serial.println("\nâŒ Unexpected HTTP Response Code");
            Serial.print("   Expected 200, got ");
            Serial.println(httpCode);
          }

        } else {
          Serial.print("\nâœ— HTTP Request Failed: ");
          Serial.println(http.errorToString(httpCode).c_str());
          Serial.println("   Check if Django server is running.");
        }

        http.end();

      } else {
        Serial.println("\nâœ— WiFi Disconnected!");
        Serial.println("   Attempting to reconnect...");
        WiFi.reconnect();
      }

      // Stop RFID reading until next card
      rfid.PICC_HaltA();
      rfid.PCD_StopCrypto1();

      Serial.println("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      Serial.println("Ready for next card...\n");
    }
  }

  // Small delay to prevent overwhelming the CPU
  delay(10);
}